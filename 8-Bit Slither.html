<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>8-bit Slither — Expanded Modes + Leaderboard</title>
<style>
  :root{
    --bg:#06121a; --panel:#0f1720; --accent:#23d160; --muted:rgba(255,255,255,0.78);
    --muted-2:rgba(255,255,255,0.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:
    linear-gradient(180deg,#041018 0%, #07131b 100%);color:#fff;overflow:hidden}
  .app{display:flex;gap:18px;padding:20px;height:100vh;align-items:center;justify-content:center;transition:all .3s}
  .sidebar{width:340px;background:rgba(255,255,255,0.02);padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  .logo{width:72px;height:72px;border-radius:10px;object-fit:cover;border:1px solid rgba(255,255,255,0.04);display:block;margin-bottom:12px}
  h1{font-size:20px;margin:0 0 6px 0}
  .desc{color:var(--muted-2);font-size:13px;margin-bottom:12px}
  .section{margin-top:12px}
  .modes{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  button{cursor:pointer;border:0;padding:10px 12px;border-radius:10px;background:rgba(255,255,255,0.02);color:var(--muted);transition:all .12s}
  button:hover{filter:brightness(1.06)}
  .active{outline:2px solid rgba(35,209,96,0.12);color:var(--accent)}
  .start-row{display:flex;gap:8px;margin-top:12px}
  .start-primary{background:var(--accent);color:#041718;font-weight:700}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  .leader{margin-top:12px;color:var(--muted-2);font-size:13px}
  .main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:12px}
  .hud{width:100%;max-width:980px;display:flex;justify-content:space-between;align-items:center}
  .hud .score{font-size:18px;font-weight:700;color:var(--muted)}
  .hud .meta{font-size:14px;color:var(--muted-2)}
  .game-wrap{background:rgba(255,255,255,0.01);padding:16px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  canvas{background:#000;border-radius:10px;display:block;margin:0 auto;box-shadow:inset 0 0 0 2px rgba(255,255,255,0.02)}
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5)}
  .modal{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:18px;border-radius:12px;min-width:320px;text-align:center}
  .modal .title{font-weight:700;margin-bottom:8px}
  .row{display:flex;gap:8px;justify-content:center}
  .controls-hint{font-size:13px;color:var(--muted-2);margin-top:10px}
  @media (max-width:1000px){ .app{flex-direction:column;padding:12px} .sidebar{width:100%} .main{width:100%} }
</style>
</head>
<body>
  <div>
<audio id="myAudio" loop>
    <source src="Retro Platforming (8-Bit Slither).mp3" type="audio/mpeg">
    <source src="Retro Platforming (8-Bit Slither).mp3" type="audio/ogg">
    Your browser does not support the audio element.
</audio>
</div>



<script>
    function playAudio() {
        var audio = document.getElementById("myAudio");
        audio.play();
    }
</script>
  <div class="app" id="app">
    <aside class="sidebar">
      <img class="logo" src="8-Bit Slither.png" alt="logo">
      <h1>8-bit Slither</h1>
      <h6>Made by PIXELFORGE NEKO STUDIOS</h6>
      <div class="desc">8-bit Slither is a retro-style snake game where you guide a pixelated snake to grow longer while avoiding walls, obstacles, and your own tail. It offers multiple modes—Classic, Adventure, Maze, Box, Friendly, Reverse, and Fast—letting players choose different challenges and speeds. Simple controls and an arcade feel make it easy to pick up but fun to master. </div>

      <div class="section">
        <div class="small" style="margin-bottom:6px">MODES</div>
        <div class="modes" id="modes">
          <button id="m-classic">Classic</button>
          <button id="m-friendly">Friendly</button>
          <button id="m-adventure">Adventure</button>
          <button id="m-maze">Maze</button>
          <button id="m-box">Box</button>
          <button id="m-reverse">Reverse</button>
          <button id="m-fast">Fast</button>
        </div>
      </div>

      <div class="section">
        <div class="small" style="margin-bottom:6px">LEVEL (BASE SPEED)</div>
        <div style="display:flex;gap:8px">
          <button class="level" data-level="1">1</button>
          <button class="level" data-level="2">2</button>
          <button class="level" data-level="3">3</button>
        </div>
      </div>

      <div class="start-row">
        <button id="start" class="start-primary">Start</button>
        <button id="demo" class="ghost">Demo</button>
      </div>

      <div class="section" style="margin-top:14px">
        <div class="small">IN-GAME</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="pause" class="ghost">Pause</button>
          <button id="menu" class="ghost">Menu</button>
          <button onclick="playAudio()">Play Music</button>
        </div>
      </div>

      <div class="leader" id="leaderPanel">
        <div style="margin-top:12px;font-weight:700">Leaderboard (session)</div>
        <ol id="leader" style="padding-left:18px;margin-top:8px"></ol>
        <div style="height:8px"></div>
        <button id="clearLB" class="ghost">Clear</button>
      </div>

      <div class="controls-hint">Controls: Arrow keys or WASD. Pause: Esc or Pause button.</div>
    </aside>

    <main class="main">
      <div class="hud">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="meta">Mode: <span id="modeLabel">—</span> • Level: <span id="levelLabel">—</span></div>
      </div>

      <div class="game-wrap">
        <canvas id="board" width="840" height="560"></canvas>
      </div>
    </main>
  </div>

  <!-- GAME OVER / LEADER MODAL -->
  <div class="overlay" id="overlay">
    <div class="modal" id="modal">
      <div class="title" id="modalTitle">Game Over</div>
      <div class="small" id="modalSub">Score: <b id="modalScore">0</b></div>
      <div style="height:8px"></div>
      <div class="row">
        <button id="retry" class="start-primary">Retry</button>
        <button id="backToMenu" class="ghost">Menu</button>
      </div>
      <div style="height:10px"></div>
      <div style="font-weight:700">Top scores (session)</div>
      <ol id="modalLeader" style="padding-left:18px;margin-top:8px;color:var(--muted-2)"></ol>
    </div>
  </div>

<script>

(() => {
  // DOM
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('start');
  const demoBtn = document.getElementById('demo');
  const pauseBtn = document.getElementById('pause');
  const menuBtn = document.getElementById('menu');
  const retryBtn = document.getElementById('retry');
  const backToMenuBtn = document.getElementById('backToMenu');
  const overlay = document.getElementById('overlay');
  const modal = document.getElementById('modal');
  const modalScore = document.getElementById('modalScore');
  const modalLeader = document.getElementById('modalLeader');

  const leaderOl = document.getElementById('leader');
  const clearLB = document.getElementById('clearLB');

  const modeButtons = {
    classic: document.getElementById('m-classic'),
    friendly: document.getElementById('m-friendly'),
    adventure: document.getElementById('m-adventure'),
    maze: document.getElementById('m-maze'),
    box: document.getElementById('m-box'),
    reverse: document.getElementById('m-reverse'),
    fast: document.getElementById('m-fast')
  };
  const levelBtns = Array.from(document.querySelectorAll('.level'));
  const scoreEl = document.getElementById('score');
  const modeLabel = document.getElementById('modeLabel');
  const levelLabel = document.getElementById('levelLabel');

  // Grid config
  const TILE = 20;
  let COLS = Math.floor(canvas.width / TILE);
  let ROWS = Math.floor(canvas.height / TILE);

  // State
  let chosenMode = 'classic';
  let chosenLevel = 1;
  let snake = [];
  let dir = {x:1, y:0};
  let food = {x:5, y:5};
  let obstacles = [];
  let score = 0;
  let running = false;
  let paused = false;
  let demoMode = false;
  let loopId = null;
  let baseInterval = 140;
  let interval = baseInterval;
  let reverseControls = false;

  // storage keys 
  function lbKey(mode){ return 'snake_lb_' + mode; }
  function loadLB(mode){ try { return JSON.parse(sessionStorage.getItem(lbKey(mode))||'[]'); } catch { return []; } }
  function saveLB(mode, arr){ sessionStorage.setItem(lbKey(mode), JSON.stringify(arr)); }

  // UI helpers
  function markModeActive(){
    Object.values(modeButtons).forEach(b => b.classList.remove('active'));
    modeButtons[chosenMode].classList.add('active');
    modeLabel.textContent = chosenMode;
  }
  function markLevelActive(){
    levelBtns.forEach(b=>b.classList.remove('active'));
    const btn = levelBtns.find(x => Number(x.dataset.level) === chosenLevel);
    if(btn) btn.classList.add('active');
    levelLabel.textContent = chosenLevel;
  }

  // Setup mode & level button listeners
  Object.keys(modeButtons).forEach(k => {
    modeButtons[k].addEventListener('click', () => {
      chosenMode = k;
      markModeActive();
    });
  });
  levelBtns.forEach(b=>{
    b.addEventListener('click', () => {
      chosenLevel = Number(b.dataset.level);
      markLevelActive();
    });
  });

  // initial UI
  markModeActive();
  markLevelActive();
  renderLeaderUI();

  // canvas size recalculation on resize
  function recalcGrid(){ COLS = Math.floor(canvas.width / TILE); ROWS = Math.floor(canvas.height / TILE); }
  window.addEventListener('resize', ()=>{ recalcGrid(); render(); });

  // core init
  function initGame(){
    recalcGrid();
    snake = [];
    const sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
    snake.push({x:sx,y:sy});
    snake.push({x:sx-1,y:sy});
    snake.push({x:sx-2,y:sy});
    dir = {x:1,y:0};
    score = 0; updateScore();
    baseInterval = chosenLevel === 1 ? 170 : chosenLevel === 2 ? 120 : 80;
    interval = baseInterval;
    reverseControls = (chosenMode === 'reverse');
    obstacles = [];
    if(chosenMode === 'maze'){
      generateMazeObstacles();
    }
    if(chosenMode === 'box'){
      // box: put walls around border
      generateBoxWalls();
    }
    if(chosenMode === 'fast'){
      // fast mode base interval lower
      interval = Math.max(30, Math.floor(baseInterval * 0.55));
    }
    placeFood();
    paused = false;
    demoMode = false;
  }

  // obstacle generators
  function generateMazeObstacles(){
    obstacles = [];
    // generate some vertical and horizontal blocks randomly
    const count = Math.max(10, Math.floor((COLS*ROWS)/180));
    let attempts = 0;
    while(obstacles.length < count && attempts < 5000){
      attempts++;
      const w = Math.floor(Math.random()*6)+2;
      const h = Math.floor(Math.random()*4)+1;
      const x = Math.floor(Math.random()*(COLS-w-2))+1;
      const y = Math.floor(Math.random()*(ROWS-h-2))+1;
      let ok = true;
      for(let oy=y; oy<y+h; oy++){
        for(let ox=x; ox<x+w; ox++){
          if(obstacles.some(o=>o.x===ox && o.y===oy)) { ok=false; break; }
          if((ox===Math.floor(COLS/2) && oy===Math.floor(ROWS/2)) ) { ok=false; break; } // avoid center
        }
        if(!ok) break;
      }
      if(ok){
        for(let oy=y; oy<y+h; oy++){
          for(let ox=x; ox<x+w; ox++){
            obstacles.push({x:ox,y:oy});
          }
        }
      }
    }
  }
  function generateBoxWalls(){
    obstacles = [];
    for(let x=0;x<COLS;x++){ obstacles.push({x:x,y:0}); obstacles.push({x:x,y:ROWS-1}); }
    for(let y=0;y<ROWS;y++){ obstacles.push({x:0,y:y}); obstacles.push({x:COLS-1,y:y}); }
  }

  // place food not on snake or obstacles
  function placeFood(){
    let tries = 0;
    do {
      food = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
      tries++;
      if(tries>2000) break;
    } while(snake.some(s=>s.x===food.x && s.y===food.y) || obstacles.some(o=>o.x===food.x && o.y===food.y));
  }

  // loop control
  function startLoop(){
    stopLoop();
    loopId = setInterval(tick, interval);
  }
  function restartLoop(){
    stopLoop();
    loopId = setInterval(tick, interval);
  }
  function stopLoop(){
    if(loopId){ clearInterval(loopId); loopId = null; }
  }

  // tick
  function tick(){
    if(paused) return;
    // demo tiny AI random moves
    if(demoMode && Math.random() < 0.12){
      const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      const c = dirs[Math.floor(Math.random()*dirs.length)];
      if(!(c.x === -dir.x && c.y === -dir.y)) dir = c;
    }

    // compute head
    let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // handle friendly wrap except box mode or classic/maze (depending on modes)
    if(chosenMode === 'friendly' && chosenMode !== 'box'){
      if(head.x < 0) head.x = COLS - 1;
      if(head.x >= COLS) head.x = 0;
      if(head.y < 0) head.y = ROWS - 1;
      if(head.y >= ROWS) head.y = 0;
    } else {
      // if box or classic or maze or fast: hitting border triggers game over
      if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
        return triggerGameOver();
      }
    }

    // obstacle collision
    if(obstacles.some(o => o.x === head.x && o.y === head.y)) return triggerGameOver();

    // self collision (ignore tail if not growing)
    const willGrow = (head.x === food.x && head.y === food.y);
    const tailIdx = snake.length - 1;
    for(let i=0;i<snake.length;i++){
      if(i === tailIdx && !willGrow) continue;
      if(head.x === snake[i].x && head.y === snake[i].y) return triggerGameOver();
    }

    // push head
    snake.unshift(head);

    // eat?
    if(willGrow){
      score++; updateScore();
      placeFood();
      // speed changes: adventure stronger accel
      if(chosenMode === 'adventure'){
        interval = Math.max(25, Math.floor(interval * 0.88));
      } else if(chosenMode === 'fast'){
        interval = Math.max(20, Math.floor(interval * 0.94));
      } else {
        // gentle speed increase per food
        interval = Math.max(40, Math.floor(interval - Math.max(3, Math.floor(4 + score*0.2))));
      }
      restartLoop();
    } else {
      // normal move
      snake.pop();
    }

    render();
  }

  // Drawing
  function clearBoard(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
  function drawGrid(){
    ctx.fillStyle = '#010101';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*TILE,0); ctx.lineTo(x*TILE,canvas.height); ctx.stroke(); }
    for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*TILE); ctx.lineTo(canvas.width,y*TILE); ctx.stroke(); }
  }
  function roundRectPath(x,y,w,h,r){
    if(w<2*r) r=w/2;
    if(h<2*r) r=h/2;
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function drawFood(){
    const cx = food.x * TILE + TILE/2;
    const cy = food.y * TILE + TILE/2;
    ctx.fillStyle = 'rgba(229,57,53,0.12)'; ctx.beginPath(); ctx.arc(cx,cy,TILE*0.6,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#e53935'; roundRectPath(food.x*TILE + TILE*0.12, food.y*TILE + TILE*0.12, TILE*0.76, TILE*0.76, TILE*0.18); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.14)'; ctx.beginPath(); ctx.arc(cx - TILE*0.12, cy - TILE*0.14, TILE*0.11,0,Math.PI*2); ctx.fill();
  }
  function drawObstacles(){
    ctx.fillStyle = '#4a4a4a';
    obstacles.forEach(o => { roundRectPath(o.x*TILE + TILE*0.12, o.y*TILE + TILE*0.12, TILE*0.76, TILE*0.76, TILE*0.18); ctx.fill(); });
  }
  function drawSnake(){
    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      const t = i / Math.max(1, snake.length-1);
      const color = i===0 ? '#84ff9b' : `rgb(${30 + (1-t)*40}, ${150 + (1-t)*80}, ${25 + (1-t)*10})`;
      ctx.fillStyle = color;
      const pad = i===0 ? TILE*0.06 : TILE*0.12;
      roundRectPath(s.x*TILE + pad, s.y*TILE + pad, TILE - pad*2, TILE - pad*2, TILE*0.28); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      roundRectPath(s.x*TILE + pad, s.y*TILE + pad + (TILE*0.44), TILE - pad*2, TILE*0.22, TILE*0.2); ctx.fill();
      if(i===0){
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.beginPath(); ctx.arc(s.x*TILE + TILE*0.66, s.y*TILE + TILE*0.37, TILE*0.06,0,Math.PI*2); ctx.fill();
      }
    }
  }
  function render(){
    clearBoard();
    drawGrid();
    drawFood();
    drawObstacles();
    drawSnake();
  }

  // trigger game over and save to session leaderboard
  function triggerGameOver(){
    stopLoop();
    running = false;
    paused = false;

    // prompt for player name (simple)
    let player = prompt("Game over! Enter your name for the session leaderboard:", "Player");
    if(!player || player.trim()==="") player = "Player";

    const lb = loadLB(chosenMode);
    lb.push({name: player, score: score, time: Date.now()});
    lb.sort((a,b)=>b.score - a.score);
    saveLB(chosenMode, lb.slice(0,10));
    showModal();
    renderLeaderUI();
  }

  // modal display
  function showModal(){
    modalScore.textContent = score;
    const lb = loadLB(chosenMode);
    modalLeader.innerHTML = lb.slice(0,5).map(r => `<li>${r.name} — ${r.score}</li>`).join('') || '<li>—</li>';
    overlay.style.display = 'flex';
  }

  // UI update score
  function updateScore(){ scoreEl.textContent = score; }

  // controls (arrow + WASD), handle reverse controls
  window.addEventListener('keydown', (e) => {
    if(!running) return;
    let key = e.key;
    // map keys with reversed option
    const mapping = {
      ArrowUp: {x:0,y:-1}, w:{x:0,y:-1}, W:{x:0,y:-1},
      ArrowDown:{x:0,y:1}, s:{x:0,y:1}, S:{x:0,y:1},
      ArrowLeft:{x:-1,y:0}, a:{x:-1,y:0}, A:{x:-1,y:0},
      ArrowRight:{x:1,y:0}, d:{x:1,y:0}, D:{x:1,y:0}
    };
    if(reverseControls){
      // invert mapping directions
      if(mapping[key]) {
        const m = mapping[key];
        const inv = {x:-m.x, y:-m.y};
        if(!(inv.x === -dir.x && inv.y === -dir.y)) dir = inv;
      }
    } else {
      if(mapping[key]){
        const m = mapping[key];
        if(!(m.x === -dir.x && m.y === -dir.y)) dir = m;
      }
    }
    if(key === 'Escape') togglePause();
  });

  // start / demo / pause / menu handlers
  startBtn.addEventListener('click', ()=>{ overlay.style.display='none'; startGame(false); });
  demoBtn.addEventListener('click', ()=>{ overlay.style.display='none'; startGame(true); });
  pauseBtn.addEventListener('click', ()=>{ togglePause(); });
  menuBtn.addEventListener('click', ()=>{ if(confirm('Return to menu? Current game will be lost.')) { stopLoop(); running=false; paused=false; overlay.style.display='none'; score=0; updateScore(); renderLeaderUI(); clearBoard(); }});
  retryBtn.addEventListener('click', ()=>{ overlay.style.display='none'; startGame(false); });
  backToMenuBtn.addEventListener('click', ()=>{ overlay.style.display='none'; stopLoop(); running=false; paused=false; score=0; updateScore(); clearBoard(); renderLeaderUI(); });

  clearLB.addEventListener('click', ()=>{ if(confirm('Clear session leaderboards?')){ saveLB(chosenMode, []); renderLeaderUI(); overlay.style.display='none'; } });

  // start game main entry
  function startGame(isDemo){
    demoMode = !!isDemo;
    running = true; paused = false;
    // set reverseControls flag if mode is reverse
    reverseControls = (chosenMode === 'reverse');
    initGame();
    startLoop();
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(paused) stopLoop(); else restartLoop();
  }

  function stopLoop(){ if(loopId){ clearInterval(loopId); loopId=null; } }
  function startLoop(){ stopLoop(); loopId = setInterval(tick, interval); }
  function restartLoop(){ stopLoop(); loopId = setInterval(tick, interval); }

  function clearBoard(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
  function updateScore(){ scoreEl.textContent = score; }

  function renderLeaderUI(){
    const lb = loadLB(chosenMode);
    leaderOl.innerHTML = lb.slice(0,5).map(r=>`<li>${r.name} — ${r.score}</li>`).join('') || '<li>—</li>';
  }

  function renderPlaceholder(){
    clearBoard();
    ctx.fillStyle = '#020202';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
    ctx.font = '18px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Choose a mode & level, then Start', canvas.width/2, canvas.height/2);
  }
  renderPlaceholder();

  window.SnakeExpanded = {
    setMode: (m) => { if(modeButtons[m]) { chosenMode = m; markModeActive(); } },
    setLevel: (l) => { chosenLevel = l; markLevelActive(); },
    startGame: () => startGame(false)
  };
})();
</script>
</body>
</html>
